{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "App.svelte",
    "NoAssumptionsProofView.svelte"
  ],
  "sourcesContent": [
    "<script lang=\"ts\">;\n;\nimport { nothing } from './Maybe';\n;\nimport { findNoAssumptionsProof } from './Proof';\nimport NoAssumptionsProofView from './NoAssumptionsProofView.svelte';\nlet state = { name: 'Neutral' };\nlet vertices = [];\nlet edges = [];\nlet xs = [];\nlet ys = [];\nlet unusedVertices = [];\nlet noAssumptionsProof = nothing();\nfunction cursorPosition(event) {\n    const svg = event.target;\n    const CTM = svg.getScreenCTM();\n    const cursorX = (event.clientX - CTM.e) / CTM.a;\n    const cursorY = (event.clientY - CTM.f) / CTM.d;\n    return { cursorX, cursorY };\n}\nfunction edgeExists(u, v) {\n    return edges.some(([a, b]) => (a === u && b === v) || (a === v && b === u));\n}\n</script>\n\n<main>\n\t<svg\n\t\ton:mousemove={event => {\n\t\t\tif (state.name === 'Dragging') {\n\t\t\t\tconst { cursorX, cursorY } = cursorPosition(event)\n\t\t\t\txs[state.vertex] = cursorX\n\t\t\t\tys[state.vertex] = cursorY\n\t\t\t\tstate = { name: 'Dragging', vertex: state.vertex, ...cursorPosition(event)\t}\t\t\n\t\t\t} else if (state.name === 'MakingEdge') {\n\t\t\t\tstate = { name: 'MakingEdge', source: state.source, ...cursorPosition(event) }\n\t\t\t}\n\t\t}}\n\t\ton:mouseup={event => {\n\t\t\tif (state.name === 'Neutral') {\n\t\t\t\tconst vertex = unusedVertices.length === 0 ? vertices.length : unusedVertices.pop()\n\t\t\t\tconst { cursorX, cursorY } = cursorPosition(event)\n\t\t\t\tvertices = [...vertices, vertex]\n\t\t\t\txs[vertex] = cursorX\n\t\t\t\tys[vertex] = cursorY\n\t\t\t} else if (state.name === 'MakingEdge') {\n\t\t\t\tstate = { name: 'Neutral' }\n\t\t\t} else if (state.name === 'SnappedEdge') {\n\t\t\t\tedges = [...edges, [state.source, state.destination]]\n\t\t\t\tstate = { name: 'Hover', vertex: state.destination }\n\t\t\t}\n\t\t}}\n\t\ton:auxclick|preventDefault\n\t\ton:contextmenu|preventDefault\n\t>\n\t\t{#each edges as [a, b]}\n\t\t\t<line class=\"edge\" stroke=\"black\"\n\t\t\t\tx1={xs[a]} y1={ys[a]}\n\t\t\t\tx2={xs[b]} y2={ys[b]}\n\t\t\t/>\n\t\t{/each}\n\n\t\t{#each vertices as vertex}\n\t\t\t<circle\tclass=\"snappable-area\" cx={xs[vertex]} cy={ys[vertex]} r=\"40\" fill=\"none\"\n\t\t\t\ton:mouseover={_ => {\n\t\t\t\t\tif (state.name === 'MakingEdge' && vertex !== state.source && !edgeExists(vertex, state.source)) {\n\t\t\t\t\t\tstate = { name: 'SnappedEdge', source: state.source, destination: vertex }\n\t\t\t\t\t}\n\t\t\t\t}}\n\n\t\t\t\ton:mouseleave={event => {\n\t\t\t\t\tif (state.name === 'SnappedEdge') {\n\t\t\t\t\t\tstate = { name: 'MakingEdge', source: state.source, ...cursorPosition(event) }\n\t\t\t\t\t}\n\t\t\t\t}}\n\n\t\t\t\ton:click={_ => {\n\t\t\t\t\tif (state.name === 'SnappedEdge') {\n\t\t\t\t\t\tedges = [...edges, [state.source, state.destination]]\n\t\t\t\t\t\tstate = { name: 'Neutral' }\n\t\t\t\t\t}\n\t\t\t\t}}\n\t\t\t/>\n\n\t\t\t<g\n\t\t\t\ton:mouseover={_ => {\n\t\t\t\t\tif (state.name === 'Neutral') {\n\t\t\t\t\t\tstate = { name: 'Hover', vertex\t}\n\t\t\t\t\t} else if (state.name === 'MakingEdge' && vertex !== state.source && !edgeExists(vertex, state.source)) {\n\t\t\t\t\t\tstate = { name: 'SnappedEdge', source: state.source, destination: vertex }\n\t\t\t\t\t}\n\t\t\t\t}}\n\n\t\t\t\ton:mouseleave={event => {\n\t\t\t\t\tif (state.name === 'Hover') {\n\t\t\t\t\t\tstate = { name: 'Neutral' }\n\t\t\t\t\t} else if (state.name === 'SnappedEdge') {\n\t\t\t\t\t\tstate = { name: 'MakingEdge', source: state.source, ...cursorPosition(event) }\n\t\t\t\t\t}\n\t\t\t\t}}\n\n\t\t\t\ton:mousedown={event => {\n\t\t\t\t\tif (state.name === 'Hover') {\n\t\t\t\t\t\tconst { cursorX, cursorY } = cursorPosition(event)\n\t\t\t\t\t\tstate = { name: 'Dragging', vertex: state.vertex, cursorX, cursorY }\n\t\t\t\t\t}\n\t\t\t\t}}\n\n\t\t\t\ton:mouseup={_ => {\n\t\t\t\t\tif (state.name === 'Dragging') {\n\t\t\t\t\t\tstate = { name: 'Hover', vertex: state.vertex }\n\t\t\t\t\t} else if (state.name === 'MakingEdge') {\n\t\t\t\t\t\tstate = { name: 'Hover', vertex: state.source }\n\t\t\t\t\t} else if (state.name === 'SnappedEdge') {\n\t\t\t\t\t\tedges = [...edges, [state.source, state.destination]]\n\t\t\t\t\t\tstate = { name: 'Hover', vertex: state.destination }\n\t\t\t\t\t}\n\t\t\t\t}}\n\n\t\t\t\ton:mousemove={event => {\n\t\t\t\t\tif (state.name === 'Dragging') {\n\t\t\t\t\t\tconst { cursorX, cursorY } = cursorPosition(event)\n\t\t\t\t\t\txs[vertex] = cursorX\n\t\t\t\t\t\tys[vertex] = cursorY\n\t\t\t\t\t\tstate = { name: 'Dragging', vertex: state.vertex, cursorX, cursorY }\t\t\n\t\t\t\t\t}\n\t\t\t\t}}\n\n\t\t\t\ton:dblclick={event => {\n\t\t\t\t\tif (state.name === 'Hover') {\n\t\t\t\t\t\tstate = {\n\t\t\t\t\t\t\tname: 'MakingEdge',\n\t\t\t\t\t\t\tsource: vertex,\n\t\t\t\t\t\t\tcursorX: xs[vertex],\n\t\t\t\t\t\t\tcursorY: ys[vertex]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}}\n\n\t\t\t\ton:auxclick|preventDefault={event => {\n\t\t\t\t\tif (state.name === 'Hover') {\n\t\t\t\t\t\tvertices = vertices.filter(v => v !== vertex)\n\t\t\t\t\t\tedges = edges.filter(([a, b]) => a !== vertex && b !== vertex)\n\n\t\t\t\t\t\tunusedVertices.push(vertex)\n\n\t\t\t\t\t\tstate = { name: 'Neutral' }\n\t\t\t\t\t}\n\t\t\t\t}}\n\n\t\t\t\ton:contextmenu|preventDefault\n\t\t\t>\n\t\t\t\t<circle\n\t\t\t\t\tclass={\n\t\t\t\t\t\t(state.name === 'Hover' || state.name === 'Dragging') && state.vertex === vertex\n\t\t\t\t\t\t\t? (state.name === 'Hover' ? 'hovering' : 'dragging')\n\t\t\t\t\t\t\t: 'neutral'\n\t\t\t\t\t}\n\t\t\t\t\tcx={xs[vertex]}\tcy={ys[vertex]}\tr=\"20\" fill=\"white\"\tstroke=\"black\"\n\t\t\t\t/>\n\n\t\t\t\t<text\n\t\t\t\t\tclass={\n\t\t\t\t\t\t(state.name === 'Hover' || state.name === 'Dragging') && state.vertex === vertex\n\t\t\t\t\t\t\t? (state.name === 'Hover' ? 'hovering' : 'dragging')\n\t\t\t\t\t\t\t: 'neutral'\n\t\t\t\t\t}\n\t\t\t\t\ttext-anchor=\"middle\" font-size=\"smaller\" x={xs[vertex]}\ty={ys[vertex]}\n\t\t\t\t>{vertex}</text>\n\t\t\t</g>\n\t\t{/each}\n\n\t\t{#if state.name === 'MakingEdge'}\n\t\t\t<line\n\t\t\t\tclass=\"preview-line\"\n\t\t\t\tstroke=\"black\"\n\n\t\t\t\tx1={xs[state.source]}\n\t\t\t\ty1={ys[state.source]}\n\n\t\t\t\tx2={state.cursorX}\n\t\t\t\ty2={state.cursorY}\n\t\t\t/>\n\t\t{/if}\n\n\t\t{#if state.name === 'SnappedEdge'}\n\t\t\t<line\n\t\t\t\tclass=\"preview-line\"\n\t\t\t\tstroke=\"black\"\n\n\t\t\t\tx1={xs[state.source]}\n\t\t\t\ty1={ys[state.source]}\n\n\n\t\t\t\tx2={xs[state.destination]}\n\t\t\t\ty2={ys[state.destination]}\n\t\t\t/>\n\t\t{/if}\n\t</svg>\n\n\t<button on:click={_ => { noAssumptionsProof = findNoAssumptionsProof(vertices, edges) }}>Analyze Colorability</button>\n\n\t{#if noAssumptionsProof.name === 'Just'}\n\t\t<NoAssumptionsProofView {vertices} {edges} noAssumptionsProof={noAssumptionsProof.value} {xs} {ys} />\n\t{/if}\n</main>\n\n<style>\n\tmain {\n\t\ttext-align: center;\n\t\tpadding: 1em;\n\t\tmax-width: 240px;\n\t\tmargin: 0 auto;\n\t}\n\n\t@media (min-width: 640px) {\n\t\tmain {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n\n\tsvg {\n\t\tdisplay: block;\n\t\tborder: 1px solid black;\n\t\theight: 700px;\n\t\twidth: 700px;\n\t}\n\n\ttext {\n\t\tpointer-events: none;\n\t}\n\n\t.hovering {\n    \tcursor: grab;\n\t}\n\n\t.dragging {\n\t\tcursor: grabbing;\n\t}\n\n\t.snappable-area {\n\t\tpointer-events: all;\n\t}\n\n\t.preview-line {\n\t\tpointer-events: none;\n\t}\n\n\t.edge {\n\t\tcursor: pointer;\n\t}\n</style>",
    "<script lang=\"ts\">;\nexport let noAssumptionsProof;\nexport let vertices;\nexport let edges;\nexport let xs;\nexport let ys;\nlet state = 'First';\nlet index = -1;\nfunction isContradictoryEdge(u, v, noAssumptionsProof) {\n    const [a, b] = noAssumptionsProof.contradictoryEdge;\n    return ((u === a && v === b) ||\n        (u === b && v === a));\n}\nfunction equalEdges([u, v], [a, b]) {\n    return (u === a && v === b) || (u === b && v === a);\n}\nfunction intermediateStrokeColor(u, v, intermediateStep) {\n    if (intermediateStep.name === 'TwoNeighborsTwoColors') {\n        if (equalEdges([u, v], [intermediateStep.firstNeighbor, intermediateStep.vertex])) {\n            return intermediateStep.colors.get(intermediateStep.firstNeighbor);\n        }\n        else if (equalEdges([u, v], [intermediateStep.secondNeighbor, intermediateStep.vertex])) {\n            return intermediateStep.colors.get(intermediateStep.secondNeighbor);\n        }\n        else {\n            return 'black';\n        }\n    }\n}\n</script>\n\n{#if state === 'First'}\n    <svg>\n        {#each edges as [a, b]}\n            <line stroke=\"black\" x1={xs[a]} x2={xs[b]} y1={ys[a]} y2={ys[b]}></line>\n        {/each}\n\n        {#each vertices as vertex}\n            <g class=\"vertex\">\n                <circle fill={\n                    vertex === noAssumptionsProof.initialRedGreenEdge[0] ? 'red' :\n                    vertex === noAssumptionsProof.initialRedGreenEdge[1] ? 'green' :\n                    'white'\n                } stroke=\"black\" r=\"20\" cx={xs[vertex]} cy={ys[vertex]} />\n                <text stroke=\"black\" x={xs[vertex]} y={ys[vertex]} text-anchor=\"middle\" font-size=\"smaller\">{vertex}</text>\n            </g>\n        {/each}\n    </svg>\n\n\n    <button disabled>Previous Step</button>\n\n    <button on:click={_ => {\n        state = 'Middle'\n        index = 0\n    }}>Next Step</button>\n{/if}\n\n{#if state === 'Middle'}\n    <svg>\n        {#each edges as [a, b]}\n            <line stroke={intermediateStrokeColor(a, b, noAssumptionsProof.intermediateSteps[index])} x1={xs[a]} x2={xs[b]} y1={ys[a]} y2={ys[b]}></line>\n        {/each}\n\n        {#each vertices as vertex}\n            {#if vertex === noAssumptionsProof.intermediateSteps[index].vertex}\n                <g class=\"vertex\">\n                    <circle fill={noAssumptionsProof.intermediateSteps[index].newColor} stroke=\"black\" r=\"20\" cx={xs[vertex]} cy={ys[vertex]} />\n                    <text stroke=\"black\" x={xs[vertex]} y={ys[vertex]} text-anchor=\"middle\" font-size=\"smaller\">{vertex}</text>\n                </g>\n            {:else}\n                <g class=\"vertex\">\n                    <circle fill={noAssumptionsProof.intermediateSteps[index].colors.has(vertex) ? noAssumptionsProof.intermediateSteps[index].colors.get(vertex) : 'white'} stroke=\"black\" r=\"20\" cx={xs[vertex]} cy={ys[vertex]} />\n                    <text stroke=\"black\" x={xs[vertex]} y={ys[vertex]} text-anchor=\"middle\" font-size=\"smaller\">{vertex}</text>\n                </g>\n            {/if}\n        {/each}\n    </svg>\n\n    <button on:click={_ => {\n        if (index === 0) {\n            index = -1\n            state = 'First'\n        } else {\n            index = index - 1\n        }\n    }}>Previous Step</button>\n\n    <button on:click={_ => {\n        if (index === noAssumptionsProof.intermediateSteps.length - 1) {\n            index = -1\n            state = 'Last'\n        } else {\n            index = index + 1\n        }\n    }}>Next Step</button>\n{/if}\n\n{#if state === 'Last'}\n    <svg>\n        {#each edges as [a, b]}\n            <line\n                stroke={isContradictoryEdge(a, b, noAssumptionsProof) ? 'red' : 'black'}\n                stroke-width={isContradictoryEdge(a, b, noAssumptionsProof) ? 3 : 1}\n                x1={xs[a]} x2={xs[b]} y1={ys[a]} y2={ys[b]}\n            />\n        {/each}\n\n        {#each vertices as vertex}\n            <g class=\"vertex\">\n                <circle fill={noAssumptionsProof.finalColors.has(vertex) ? noAssumptionsProof.finalColors.get(vertex) : 'white' } stroke=\"black\" r=\"20\" cx={xs[vertex]} cy={ys[vertex]} />\n                <text stroke=\"black\" x={xs[vertex]} y={ys[vertex]} text-anchor=\"middle\" font-size=\"smaller\">{vertex}</text>\n            </g>\n        {/each}\n    </svg>\n\n    <button on:click={_ => {\n        index = noAssumptionsProof.intermediateSteps.length - 1\n        state = 'Middle'\n    }}>Previous Step</button>\n\n    <button disabled>Next Step</button>\n{/if}\n\n\n<style>\n    svg {\n        display: block;\n        height: 700px;\n        width: 700px;\n    }\n</style>"
  ],
  "names": [],
  "mappings": "AA+MC,IAAI,cAAC,CAAC,AACL,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CACZ,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,AACf,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,IAAI,cAAC,CAAC,AACL,SAAS,CAAE,IAAI,AAChB,CAAC,AACF,CAAC,AAED,GAAG,cAAC,CAAC,AACJ,OAAO,CAAE,KAAK,CACd,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,CACvB,MAAM,CAAE,KAAK,CACb,KAAK,CAAE,KAAK,AACb,CAAC,AAED,IAAI,cAAC,CAAC,AACL,cAAc,CAAE,IAAI,AACrB,CAAC,AAED,SAAS,cAAC,CAAC,AACP,MAAM,CAAE,IAAI,AAChB,CAAC,AAED,SAAS,cAAC,CAAC,AACV,MAAM,CAAE,QAAQ,AACjB,CAAC,AAED,eAAe,cAAC,CAAC,AAChB,cAAc,CAAE,GAAG,AACpB,CAAC,AAED,aAAa,cAAC,CAAC,AACd,cAAc,CAAE,IAAI,AACrB,CAAC,AAED,KAAK,cAAC,CAAC,AACN,MAAM,CAAE,OAAO,AAChB,CAAC;AC3HE,GAAG,eAAC,CAAC,AACD,OAAO,CAAE,KAAK,CACd,MAAM,CAAE,KAAK,CACb,KAAK,CAAE,KAAK,AAChB,CAAC"
}